use std::fmt;
use crate::dimensions::tag::Tag;

#[derive(Clone,PartialEq,Debug)]
enum Severity {
  Negligible = 0,
  Marginal = 1,
  Critical = 2,
  Catastrophic = 3
}

#[derive(Clone,PartialEq)]
pub struct VulnerabilityEnvironment {
  name : String,
  severity : Severity,
  pub assets : Vec<String>  
}

impl VulnerabilityEnvironment {
  pub fn new(env_name: &String, sev: &String) -> VulnerabilityEnvironment {
    VulnerabilityEnvironment { 
      name: env_name.clone(),
      severity  : match sev.as_str() {
        "Negligible" => Severity::Negligible,
        "Marginal" => Severity::Marginal,
        "Critical" => Severity::Critical,
        "Catastrophic" => Severity::Catastrophic,
        _ => panic!("{} is an invalid severity value", sev)
      }, 
      assets: Vec::<String>::new() 
    }
  }
}

#[test]
fn test_new_vulnerability_environment() {
  let ve = VulnerabilityEnvironment::new(&"Default".to_string(),&"Marginal".to_string());
  assert_eq!(ve.name,"Default".to_string());
  assert_eq!(ve.severity,Severity::Marginal);
  assert_eq!(ve.assets.len(),0);
}

impl fmt::Display for VulnerabilityEnvironment {
  fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
    write!(f,"Environment: {}, Severity: {}, Assets: {}",
      self.name,
      match self.severity {
        Severity::Negligible => "Negligible",
        Severity::Marginal => "Marginal",
        Severity::Critical => "Critical",
        Severity::Catastrophic => "Catastrophic" 
      },
      self.assets.join(","))
  }
}

#[derive(Clone,PartialEq)]
pub struct Vulnerability {
  name : String,
  vulnerability_type : String,
  pub description : String,
  pub tags : Vec<Tag>,
  pub environments : Vec<VulnerabilityEnvironment>  
}

impl Vulnerability {
  pub fn new(vul_name : &String, vul_type : &String) -> Vulnerability {
    Vulnerability { 
      name: vul_name.clone(), 
      vulnerability_type: vul_type.clone(),
      description: "".to_string(), 
      tags: Vec::<Tag>::new(), 
      environments: Vec::<VulnerabilityEnvironment>::new() 
    }
  }
}

#[test]
fn test_new_vulnerability() {
  let v = Vulnerability::new(&"Some vulnerability".to_string(),&"Some type".to_string());
  assert_eq!(v.name,"Some vulnerability".to_string());
  assert_eq!(v.vulnerability_type,"Some type".to_string());
  assert_eq!(v.description,"".to_string());
  assert_eq!(v.tags.len(),0);
  assert_eq!(v.environments.len(),0);
}

impl fmt::Display for Vulnerability {
  fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
    let envs = &self.environments.iter().map(|env| env.to_string()).collect::<Vec<String>>().join(",");
    let tags = &self.tags.iter().map(|t| t.name.clone()).collect::<Vec<String>>().join(",");
    write!(f,"Name: {}, Type: {}, Description: {}, Tags: {}, Environments: {}",self.name,self.vulnerability_type,self.description,tags,envs)
  }
}
